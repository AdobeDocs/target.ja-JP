---
keywords: レコメンデーションアルゴリズム；モデルトレーニング；モデル提供；コンテンツ配信；項目ベース；ユーザーベース；人気度ベース；買い物かごベース；カスタム条件
description: で使用されるアルゴリズムについて説明します。 [!DNL Target Recommendations]（モデルトレーニングやモデルサービングを含む）
title: Target のRecommendationsアルゴリズムの背後にある Science については、どこで学習できますか？
feature: Recommendations
mini-toc-levels: 2
exl-id: c156952b-8eda-491d-a68e-d3d09846f640
source-git-commit: a0a20b99a76ba0346f00e3841a345e916ffde8ea
workflow-type: tm+mt
source-wordcount: '2858'
ht-degree: 0%

---

# ![プレミアム](/help/main/assets/premium.png) Target のレコメンデーションアルゴリズムの背後にある科学

で使用されるアルゴリズムの詳細な説明 [!DNL Adobe Target Recommendations]（モデルトレーニングのロジックと数学的な詳細、およびモデル提供のプロセスを含む）

モデルトレーニングは、 [!DNL Adobe Target] 学習アルゴリズム。 モデルの提供は次のようになります [!DNL Target] は、サイト訪問者にレコメンデーションを配信します（コンテンツ配信とも呼ばれます）。

[!DNL Target] には、次の幅広いタイプのアルゴリズムが含まれています [!DNL Recommendations]:

* **項目ベースのアルゴリズム**:「この品目を閲覧した人が他にこの品目を閲覧した/購入したものも、これらの品目を閲覧/購入した」論理に従うアルゴリズムを含めます。 これらのアルゴリズムは、包括的な項目と項目の協調フィルタリングの下にグループ化され、 [!UICONTROL 類似の属性を持つ品目] アルゴリズム

* **ユーザーベースのアルゴリズム**:次を含める： [!UICONTROL 最近表示された項目] および [!UICONTROL お勧め] アルゴリズム

* **人気度ベースのアルゴリズム**:Web サイト全体で最も多く閲覧された品目または最も多く購入された品目、またはカテゴリまたは品目属性別に最も閲覧された品目または最も多く購入された品目を返すアルゴリズムを含めます。

* **買い物かごベースのアルゴリズム**:複数品目ベースのレコメンデーションを、「これらの品目を閲覧した人が購入した、またはそれらの品目を閲覧または購入した」というロジックと共に含めます。

* **カスタム条件**:にアップロードされたカスタムファイルに基づくレコメンデーションを含める [!DNL Target].

>[!NOTE]
>
>各アルゴリズムタイプと個々のアルゴリズムについて詳しくは、 [レコメンデーションキーに基づくレコメンデーションの設定](/help/main/c-recommendations/c-algorithms/base-the-recommendation-on-a-recommendation-key.md).

上記のアルゴリズムの多くは、1 つ以上のキーの存在に基づいています。 これらのキーは、（レコメンデーションがおこなわれた場合に）コンテンツ配信時に類似した品目を取得するために使用されます。 顧客指定のキーには、その訪問者が閲覧している現在の品目、最後に閲覧または購入した品目、最も多く閲覧された品目、現在のカテゴリ、お気に入りのカテゴリが含まれます。 買い物かごベースやユーザーベースのレコメンデーションなど、他のアルゴリズムは、暗黙のキーを使用します（顧客が設定できない）。 詳しくは、 *レコメンデーションキー*、 [レコメンデーションキーに基づくレコメンデーションの設定](/help/main/c-recommendations/c-algorithms/base-the-recommendation-on-a-recommendation-key.md#keys). ただし、これらのキーはモデル提供時にのみ関連します（コンテンツ配信）。 これらのキーは、「オフライン」またはモデルトレーニング時間ロジックには影響しません。

以下の節では、上記のアルゴリズムタイプとは少し異なる方法でアルゴリズムをグループ化します。 次のグループは、モデルトレーニングロジックの類似性に基づいています。

## 項目と項目の協調フィルタリング

アルゴリズムの内容は次のとおりです。

* [!UICONTROL これを閲覧した人が他に閲覧したもの]
* [!UICONTROL これを閲覧した人が購入したもの]
* [!UICONTROL これを購入した人が他に購入したもの]

品目 — 品目の協調フィルタリングのレコメンデーションアルゴリズムは、多くのユーザーの行動パターン（つまり協調）を使用して、特定の品目に有用なレコメンデーションを提供する必要があるという考えに基づいています。 一般的な傘の下には様々なアルゴリズムが存在しますが [協調フィルタリング](https://en.wikipedia.org/wiki/Collaborative_filtering)の場合、これらのアルゴリズムは一般的に行動データソースを入力として使用します。 In [!DNL Target Recommendations]に値を入力すると、ユーザー別のアイテムの一意のビューおよび購入になります。

「この品目を閲覧/購入した人がこれらの品目も閲覧/購入した」アルゴリズムの目標は、すべての品目のペアの間の類似性 s(A、B) を計算することです。 特定の品目 A に対して、上位のレコメンデーションは、類似性 s(A、B) で並べ替えられます。

このような類似性の例の 1 つは、項目間での共起です。両方の品目を購入したユーザーの単純数。 直感的な指標ですが、人気のある商品をレコメンデーションする方向に偏っている点で、そのような指標は素朴です。 例えば、食料品店でパンを買う人が多い場合、パンは全ての商品との共生度が高くなりますが、必ずしも良いお勧めとは限りません。 [!DNL Target] の代わりに、ログ尤度比 (LLR) と呼ばれる、より高度な類似性指標を使用します。 この量は、A と B の 2 つの項目の確率が、共同発生しない確率と非常に異なる場合に大きくなります。 具体性に関しては、次のような場合を考えてみましょう。 [!UICONTROL これを閲覧した人が購入したもの] アルゴリズム。 LLR 類似性は、B が購入された確率が高い場合に大きくなります *not* 誰かが A を見たかどうかに関係なく

例えば、

![閲覧済み/購入済みのアルゴリズムの数式](assets/formula.png)

品目 A では品目 B を推奨しないでください。このログの尤度比の類似性の計算の詳細が提供されます [このPDF](/help/main/c-recommendations/c-algorithms/assets/log-likelihood-ratios-recommendation-algorithms.pdf).

次の回路図に、実際のアルゴリズム実装の論理的な流れを示します。

![閲覧済み/購入済みのアルゴリズムの回路図](assets/diagram1.png)

これらの手順の詳細は次のとおりです。

* **データを入力**:収集した訪問者のビューおよび購入の形式の行動データ [Target の実装](https://developer.adobe.com/target/implement/recommendations/){target=_blank} または [Adobe Analytics](/help/main/c-recommendations/c-algorithms/use-adobe-analytics-with-recommendations.md).

* **モデルトレーニング**:

   * **データクレンジングとサンプリング**:N 日間のルックバックを含むアルゴリズムの場合、行動データは最初にフィルタリングされ、N 日間のデータのみが含まれます。 次に、収集ルールとグローバル除外が適用され、レコメンデーションすべきでない品目が削除されます。 最後に、1,000 個を超える項目を操作した訪問者の使用状況データは、1,000 個の項目にしかサンプルされません。
   * **項目の類似性の計算**:次に、主な計算手順を示します。すべての候補項目のペア間のログ尤度の比率の類似性を計算し、この類似性スコアによって項目のペアをランク付けします。
   * **オフラインフィルター**:最後に、その他の適用可能な動的フィルター（動的カテゴリの除外など）が適用されます。 この手順の後、事前に計算された Recommendations は、提供に使用できるよう、グローバルにキャッシュされます。

* **モデルサービング**:Recommendationsコンテンツの配信元 [!DNL Target]&#39;s [グローバル「Edge」ネットワーク](/help/main/c-intro/how-target-works.md#concept_0AE2ED8E9DE64288A8B30FCBF1040934). mbox リクエストが [!DNL Target] レコメンデーションコンテンツは、適切な [項目キー](/help/main/c-recommendations/c-algorithms/base-the-recommendation-on-a-recommendation-key.md#keys) recommendations アルゴリズムは、リクエストから解析されるか、ユーザープロファイルから検索され、前の手順で計算されたレコメンデーションを取得するために使用されます。 現時点では、適切な [デザイン](/help/main/c-recommendations/c-design-overview/create-design.md) がレンダリングされます。

## コンテンツの類似性

含まれるアルゴリズム：

* [!UICONTROL 類似の属性を持つ品目]

このタイプのアルゴリズムでは、名前とテキストの説明が意味的に類似している場合、2 つの項目が関連していると見なされます。 行動データソースを使用する必要があるほとんどの recommendations アルゴリズムとは異なり、コンテンツの類似性アルゴリズムは、商品カタログからのメタデータを使用して、品目間の類似性を導き出します。 [!DNL Target] したがって、( 例えば、 [!DNL Target] アクティビティ )。

モデルサービングとコンテンツ配信の側面は [!DNL Target]のコンテンツ類似性アルゴリズムは、他の項目ベースのアルゴリズムと同じです。モデルトレーニング手順は大幅に異なり、次の図に示す一連の自然言語処理および前処理手順が含まれます。 類似性計算の中心は、カタログ内の各項目を表す、変更された tf-idf ベクトルの余弦の類似性の使用です。

![コンテンツ類似性プロセスのフローを示す図](assets/diagram2.png)

これらの手順の詳細は次のとおりです。

* **データを入力**:前述のように、このアルゴリズムは、純粋にカタログデータに基づいています ( [!DNL Target] 経由 [カタログフィード、エンティティ API、またはページ上の更新から](https://developer.adobe.com/target/implement/recommendations/).

* **モデルトレーニング**:

   * **属性の抽出**:通常の静的フィルター、カタログルールおよびグローバル除外の適用後、このアルゴリズムは、エンティティスキーマから関連するテキストフィールドを抽出します。 [!DNL Target] は、エンティティ属性の名前、メッセージ、カテゴリの各フィールドを自動的に使用し、カスタムから任意の文字列フィールドを抽出しようとします [エンティティ属性](/help/main/c-recommendations/c-products/entity-attributes.md). この処理は、そのフィールドの値の大部分を数値、日付、ブール値として解析できないようにすることでおこなわれます。
   * **ステミングおよび停止語の削除**:より正確なテキスト類似性の照合をおこなうには、項目の意味を大きく変更しない一般的な「stop」単語（「was」、「is」、「and」など）を削除することをお勧めします。 同様に、ステミングとは、同じ意味を持つ（例えば、「connect」、「connecting」、「connection」、「connection」など）、それぞれが同じルートワードを持つ、異なるサフィックスを持つ単語を減らすプロセスを指します。&quot;connect&quot;) です。 [!DNL Target] は Snowball ステマーを使用します。 [!DNL Target] は最初に自動言語検出を実行し、最大 50 言語に対して単語の削除を停止し、18 言語に対してステミングを実行できます。
   * **n グラム生成**:上記の手順の後、各単語はトークンとして扱われます。 複数のトークンの連続したシーケンスを 1 つのトークンに組み合わせるプロセスを、n-gram 作成と呼びます。 [!DNL Target]アルゴリズムは、最大 2 グラムを考慮します。
   * **tf-idf 計算**:次の手順では、項目の説明におけるトークンの相対的な重要性を反映する tf-idf ベクトルを作成します。 項目 i の各トークン/用語 t に対して、 |D|項目を指定した場合、用語の頻度 TF(t, i) が最初に計算されます（項目 i に用語が出現する回数）。また、文書の頻度 DF(t, D)。 要するに、トークンが存在する項目の数です。 tf-idf の測定は次のとおりです

      ![tf-idf 測定を示す数式](assets/formula2.png)

      [!DNL Target] は Apache Spark の *tf-idf* 機能化実装。内部では、各トークンを 218 個のトークンのスペースにハッシュ化します。 この手順では、顧客が指定した属性ブースティングと埋め込みも、 [条件](/help/main/c-recommendations/c-algorithms/create-new-algorithm.md#similarity).

   * **項目の類似性の計算**:最終的な項目類似性計算は、近似コサイン類似性を使用して行われます。 2 つの項目に対して *A* および *B*&#x200B;を返します。ベクトル tA と tB を使用すると、コサインの類似性は次のように定義されます。

      ![品目類似性計算を示す数式](assets/formula3.png)

      すべての N x N 項目間の類似点を計算する際の大幅な複雑さを回避するには、 *tf-idf* ベクトルは、最大 500 個のエントリのみを含むように切り捨てられ、この切り捨てられたベクトル表現を使用して項目間のコサインの類似性を計算します。 このアプローチは、局所感応性ハッシュなどの他の近隣近傍 (ANN) の手法に比べ、疎ベクトル類似性計算に対してより堅牢であることが証明されています。

   * **モデルサービング**:この手順は、前の節で説明した項目間の協調フィルタリング手法と同じです。

## 複数キーのレコメンデーション

アルゴリズムの内容は次のとおりです。

* 買い物かごベースのレコメンデーション
* [!UICONTROL お勧め]

最新の [!DNL Target] レコメンデーションアルゴリズムのスイートは、 [!UICONTROL お勧め] と、買い物かごベースの一連のレコメンデーションアルゴリズムを参照してください。 どちらのタイプのアルゴリズムも、協調フィルタリングの手法を使用して、個々の項目ベースのレコメンデーションを形成します。 次に、サーバータイムで、ユーザーの閲覧履歴の複数の項目 ( [!UICONTROL お勧め]) や、ユーザーの現在の買い物かご（買い物かごベースのレコメンデーション用）を使用してこれらの項目ベースのレコメンデーションを取得し、結合されてレコメンデーションの最終リストが作成されます。 パーソナライズされたレコメンデーションアルゴリズムには、多くの種類が存在することに注意してください。 複数キーアルゴリズムを選択すると、訪問者が閲覧履歴を持っている場合にレコメンデーションがすぐに利用可能になり、最新の訪問者の行動に応じてレコメンデーションを更新できます。

これらのアルゴリズムは、品目ベースのレコメンデーションの節で説明した基本的な協調フィルタリング手法に基づいて構築され、品目間の最適な類似性指標を決定するためのハイパーパラメーターの調整も組み込まれています。 アルゴリズムは、各ユーザーの行動データの時系列分割を実行し、ユーザーが後で閲覧または購入する項目を予測しながら、前のデータに対してレコメンデーションモデルをトレーニングします。 最適な [平均精度](https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval)#Mean_average_precision) が選択されます。

次の図に、モデルのトレーニング手順とスコアリング手順のロジックを示します。

![モデルのトレーニングステップとスコアリングステップのロジックを示す図](assets/diagram3.png)

これらの手順の詳細は次のとおりです。

* **データを入力**:これは、品目 — 品目協調フィルタリング (CF) メソッドと同じです。 [!UICONTROL 両方をお勧めします] および買い物かごベースのアルゴリズムは、ユーザーが収集した閲覧と購入の形式で、行動データを使用します。 [Target の実装](https://developer.adobe.com/target/implement/recommendations/){target=_blank} または [Adobe Analytics](/help/main/c-recommendations/c-algorithms/use-adobe-analytics-with-recommendations.md).

* **モデルトレーニング**:

   * **データクレンジングとサンプリング**:これは、協調フィルタリング方法と同じです。ルックバックウィンドウを適用して行動データを適切な日付範囲にフィルタリングし、カタログルールとグローバル除外を適用します。 1,000 個を超える商品を操作した訪問者は、最新の 1,000 個の使用状況のみを考慮しています。
   * **トレーニングテストの分割**:各ユーザーの使用状況を時系列で分割し、使用状況の最初の 80%をトレーニングデータに割り当て、残りの 20%をテストデータに割り当てます。
   * **品目類似性モデルトレーニング**:コア項目の類似性の計算は、 [!UICONTROL お勧め] および買い物かごベースのアルゴリズムを使用して、候補の項目ベクトルを作成する方法について説明します。 の場合 [!UICONTROL お勧め]の場合、項目ベクトルにはディメンション NUsers があり、各エントリは項目のユーザーに対する暗黙の評価の合計を表します。項目の購入は、項目のビューの 2 倍の重み付けが与えられます。 買い物かごベースのレコメンデーションの場合、項目ベクトルにはバイナリエントリが含まれます。セッション内の動作だけを考慮する場合は、各セッションに新しいエントリが存在します。 それ以外の場合は、すべての訪問者に対して、この項目ベクトルにエントリが存在します。

   トレーニングステップでは、複数のタイプのベクトル類似性を計算します。LLR 類似性 ([ここで述べる](/help/main/c-recommendations/c-algorithms/assets/log-likelihood-ratios-recommendation-algorithms.pdf))、コサインの類似性（既に定義）および正規化された L2 類似性 ( 以下のように定義されます。

   ![トレーニング計算を示す数式](assets/formula4.png)

   * **品目類似性モデルの評価**:モデル評価は、前の手順で生成したレコメンデーションを使用し、テストデータセットに関する予測をおこなうことでおこなわれます。 オンラインスコアリングフェーズは、テストデータセット内の各ユーザーの項目の使用状況を時系列に並べ替え、以降のビューと購入を予測するために、項目の順序付きサブセットに対して 100 個のレコメンデーションを行うことで模倣されます。 情報取得指標 [平均精度](https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval)#Mean_average_precision)を使用して、これらのレコメンデーションの品質を評価します。 この指標では、レコメンデーションの順序を考慮し、レコメンデーションのリストの上位にある関連項目を優先します。これは、システムのランキングに重要なプロパティです。
   * **モデルの選択**:オフライン評価の後、平均精度が最も高いモデルが選択され、そのモデルに対して計算された個々の品目 — 品目レコメンデーションがすべて選択されます。
   * **オフラインフィルター**:モデルトレーニングの最終段階は、適用可能な動的フィルターの適用です。 この手順の後、事前に計算された Recommendations は、提供に使用できるよう、グローバルにキャッシュされます。


* **モデルサービング**:以前のアルゴリズムでは、レコメンデーションを提供する際に取得用に単一のキーを指定し、その後にビジネスルールを適用することが必要でしたが、それとは異なり、 [!UICONTROL お勧め] と買い物かごベースのアルゴリズムは、より複雑なランタイムプロセスを使用します。

   * **複数キーの取得と結合**:買い物かごベースのレコメンデーションの場合、買い物かごに渡された最大 10 個の項目が取得のキーと見なされ、各項目のレコメンデーションが等しく重み付けされます。 の場合 [!UICONTROL お勧め]を使用すると、最後の 5 つまでの個別閲覧品目と最後の 5 つの個別購入品目が検索のキーと見なされ、購入した品目から生じるレコメンデーションは、閲覧した品目から生じるレコメンデーションの 2 倍に重み付けされます。 レコメンデーションを結合する際に、1 つの項目がレコメンデーションの複数の個々のリストに表示される場合、その重み付け類似性スコアが追加されます。 このステージのレコメンデーションの最後のリストは、再重み付けされたレコメンデーションの結合リストで、降順にランク付けされます。
   * **フィルター**:次に、以前に表示した品目や購入した品目の削除などのフィルタールールや、他の動的なビジネスルールが適用されます。

これらのプロセスを次の図に示します。訪問者が品目 A と購入した品目 B を閲覧します。個々のレコメンデーションは、各品目ラベルの下に表示されるオフラインの類似性スコアを使用して取得されます。 取得後、レコメンデーションは、合計された重み付け類似性スコアと結合されます。 最後に、顧客が以前表示および購入した品目を除外する必要があることを指定したシナリオでは、フィルタリング手順により、レコメンデーションのリストから品目 A および B が削除されます。

![複数キーアルゴリズムの処理を示す図](assets/diagram4.png)

## 人気度ベース

アルゴリズムの内容は次のとおりです。

* [!UICONTROL サイト全体で最も多く閲覧された]
* [!UICONTROL カテゴリ別の最も多く閲覧された項目]
* [!UICONTROL 品目属性別最も多く閲覧された品目]
* [!UICONTROL サイト全体のトップセラー]
* [!UICONTROL カテゴリ別のトップセラー]
* [!UICONTROL 品目属性別トップセラー]

[!DNL Target] では、最も多く閲覧された品目と、Web サイト全体でのトップセラー品目の両方に対して、または品目属性またはカテゴリで分類された人気度ベースのアルゴリズムを提供します。 人気度に基づくアルゴリズムは、特定の期間内に品目が閲覧または購入されたセッション数に基づいて品目をランク付けします。

これらのアルゴリズムはすべて、集計された行動データを組み合わせて、品目が閲覧され、購入されたセッションの合計数を時間別と日別の解像度で記録します。 その後、個々のアルゴリズムは、顧客が設定したルックバックウィンドウで最も多く閲覧された品目または最も購入された品目を見つけます。

個々のアルゴリズムの微妙な違いは次のとおりです。

* [!UICONTROL サイト全体で最も多く閲覧された] および [!UICONTROL サイト全体のトップセラー] 項目を、それぞれ閲覧または購入されたセッションの総数でランク付けします。 出力は、レコメンデーションされた品目の 1 つの（キーレスの）リストです。
* カテゴリ/品目属性別の最も多く閲覧された/トップセラーは、品目が閲覧または購入されたセッションの集計数に基づいて品目が並べられ、品目カテゴリまたは特定の品目属性別にグループ化されたレコメンデーションです。 出力は、カテゴリの値または項目属性の値でキー設定された、レコメンデーションされた項目のリストです。

## 最近表示された項目

「最近表示された」レコメンデーションアルゴリズムを使用すると、セッション内でレコメンデーションをパーソナライズできます。 このアルゴリズムには、オフラインの「モデルトレーニング」は必要ありません。 代わりに、 [!DNL Target] は、一意の [訪問者プロファイル](/help/main/c-target/c-visitor-profile/visitor-profile.md) 特定のセッションで閲覧された品目の実行中のリストを維持し、これらの品目を recommendations アクティビティで表示できるようにする。 これにより、レコメンデーションと次のページのパーソナライゼーションに対するリアルタイムの更新が可能になります。

## カスタム条件

カスタム条件を使用すると、 [自分のレコメンデーションを～にアップロードする [!DNL Target]](/help/main/c-recommendations/c-algorithms/recommendations-csv.md)：重要な柔軟性を提供し、「独自のモデルを持ち込む」機能を可能にします。 カスタム条件は、 [!UICONTROL 項目ベース] レコメンデーションの取得に単一のキーが使用され、ビジネスルール/フィルターが適用されるという点で、レコメンデーションは、オンラインコンテンツ配信フェーズでは項目ベースのレコメンデーションアルゴリズムと同様に動作します。
